# PE129
Project Euler #129

Problem Description:

A number consisting entirely of ones is called a repunit. We shall define R(k) to be a
repunit of length k; for example, R(6) = 111111 .

Given that n is a positive integer and gcd(n,10) = 1, it can be shown that there always
exists a value, k, for which R(k) is divisible by n, and let A(n) be the least such value of
k.

Given n, compute A(n).

Solution Description:

Let k=phi(9n) where phi() is the Euler totient function.
10^k = 1 (mod 9n) (By Eulerâ€™s Theorem)
Therefore R(k) = (10^k-1)/9 = 0 (mod n).
This provides an algorithm for calculating a repunit divisible by n, however, by inspection it is
immediately apparent that R(phi(9n)) is not typically the smallest repunit divisible by n. It can be
shown that phi(9n) must be divisible by A(n).
Proof by contradiction:
Assume phi(9n) not divisible by A(n).
Let phi(9n) / A(n) = Y r X (0 &lt; X &lt; A(n) )
R(phi(9n)) / (R(A(n))^Y) = R(X) 10^(A(n)Y)
Since this value must be divisible by n, and gcd(n,10)=1, R(X) must be divisible by n.
Therefore R(A(n)) is not the smallest repunit divisible by n.
This reduces the complexity of the problem, as it allowed me to check only whole multiples of
phi(9n).

Calculating both the totient, and all whole factors of the totient requires iterating through primes,
The code is therefore optimized by pre-calculating all primes up to sqrt(N) (where N=10^13 is
the largest expected value of n).
Using a naive approach, calculating R(k)%n has the same complexity as iterating through all x
0<x<k. The primary speed-up comes from incrementing R(k) in increments of powers of 2.
R(k+2^x) = R(k)*10^2^x+R(2^x), and pre-calculating 10^2^x and R(2^x) for 0<x<80 modulo n.

Files:

generate_input.cpp
Usage: generate_input N Y
N = number of input trials
10^Y = Max trial value

Outputs a test input file of N numbers 1 < n < 10^Y

Ones.cpp

Reads from standard input using the format of the output generated by generate_input.cpp and outputs A(n) for each input n as defined above.
